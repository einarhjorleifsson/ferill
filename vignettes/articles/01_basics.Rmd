---
title: "Basics"
date: "`r lubridate::now()`"
---

```{r}
# https://statsandr.com/blog/outliers-detection-in-r/
```


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = "#>"
)
```

```{r}
library(sf)
library(mapview)
library(mapdeck)
library(lubridate)
# remotes::install_github("einarhjorleifsson/ramb")
library(ramb)
library(tidyverse) # alway load this last (because of potential function name conflicts)
```

```{r}
# some conventient functions
read_wgssfgeo_harbour <- function() {
  tmpfile <- tempfile()
  download.file("https://raw.githubusercontent.com/ices-eg/WKSSFGEO/main/jepol/harbours.rds", destfile = tmpfile)
  readRDS(tmpfile)
}
```

```{r, echo = FALSE}
fil <- "~/r/Pakkar2/ramb/TOPSECRET.R"
if(file.exists(fil)) source(fil) 
```

# Some scandinavian data - case example 1

## Preprocess the data

```{r}
d <-
  "https://raw.githubusercontent.com/ices-eg/WKSSFGEO/main/example_data_AIS.csv" %>% 
  read_csv() %>% 
  # get rid of prefix in vessel_id, here we can turn things to integer
  mutate(vid = str_sub(vessel_id, 4) %>% as.integer()) %>% 
  # make typing downtream a little less painful
  rename(time = time_stamp,
         gid = gear) %>% 
  # make sure time is in order within a vessel
  arrange(vid, time) %>% 
  # time has to be unique %>% 
  distinct(vid, time, .keep_all = TRUE) %>% 
  # unique row id, may be useful downstream
  mutate(.rid = 1:n()) %>%
  select(.rid, vid, time:behaviour)
nrow0 <- d %>% nrow() # used for double checks downstream
```


## Points in harbour

This is a classical point in polygon problem ([see e.g. example](https://splatter.netlify.app/posts/2019-01-17-geoinside-points-in-polygons-via-sf)). {sf}-functions come to the rescue

```{r}
hbs <- 
  read_wgssfgeo_harbour() %>% 
  # unique harbour id
  mutate(hid = 1:n()) %>% 
  select(hid)
d <-
  d %>% 
  st_as_sf(coords = c("lon", "lat"),
           crs = 4326,
           remove = FALSE) %>% 
  st_join(hbs) %>% 
  # having geometry may cause problem downstream, hence dropped
  st_drop_geometry()

nrow(d) == nrow0 # anything unexpected?
# peekaboo
d %>% 
  count(hid)
```

## Definition of trips

Consequitive points outside harbour are constitute a trip. The function below
assigns a negative value for points inside harbour, each "harbour trip" gets
a unique sequential negative number (-1, -2, ...).

```{r}
d <- 
  d %>% 
  ramb::rb_define_trip()

nrow(d) == nrow0 # anything unexpected?
# peekaboo
d %>% 
  ungroup() %>% 
  filter(tid > 0) %>% 
   # cap trip numbers, just for visuals, 19 trips is "a plus groups"
  mutate(tid = ifelse(tid >= 19, 19, tid)) %>% 
  count(vid, tid) %>% 
  spread(tid, n) %>% 
  knitr::kable(caption = "Number of pings per trip per vessel")
```


## Whacky points


```{r}
d <- 
  d %>% 
  group_by(vid, tid) %>% 
  mutate(pings = n(),
         dist    = ifelse(pings >= 3, traipse::track_distance(lon, lat), NA),     # meters
         dura    = traipse::track_time(time),                                     # seconds
         speed2  = ifelse(pings >= 3, traipse::track_speed(lon, lat, time), NA),  # ms
         bearing = traipse::track_bearing(lon, lat),                              # degrees
         angle   = ifelse(pings >= 3, traipse::track_angle(lon, lat), NA),        # degrees
         turn    = traipse::track_turn(lon, lat)) %>%                             # degrees
  ungroup()

nrow(d) == nrow0 # anything unexpected?
```

### Distance 

```{r}
d %>% 
  filter(tid > 0) %>% 
  mutate(dist = round(dist)) %>% # just for downstream display
  rb_peek(dist, 100) %>% 
  select(.rid:speed, tid, dist:speed2, bearing, whacky) %>% 
  mutate(dist = round(dist),
         speed2 = round(speed2),
         bearing = round(bearing)) %>% 
  knitr::kable(digits = 4,
               caption = "Records (and adjacent records) where step distance is more than 100 m")
```

### Time step 

```{r}
d %>% 
  filter(tid > 0) %>% 
  mutate(dist = round(dist)) %>% # just for downstream display
  rb_peek(dura, 10 * 10) %>% 
  select(.rid:speed, tid, dist:speed2, whacky) %>% 
  knitr::kable(digits = 4,
               caption = "Records (and adjacent records) where time step 100 seconds")
```

### Speed 

```{r}
d %>% 
  filter(tid > 0) %>% 
  mutate(dist = round(dist)) %>% # just for downstream display
  rb_peek(speed, 20) %>% 
  select(.rid:speed, tid, dist:speed2, whacky) %>% 
  knitr::kable(digits = 4,
               caption = "Records (and adjacent records) where speed is more than 20 knots")
```

### Derived speed 

```{r}
d %>% 
  filter(tid > 0) %>% 
  mutate(dist = round(dist)) %>% # just for downstream display
  mutate(speed2 = ramb::ms2kn(speed2)) %>% 
  rb_peek(speed2, 20) %>% 
  select(.rid:speed, tid, dist:speed2, whacky) %>% 
  knitr::kable(digits = 4,
               caption = "Records (and adjacent records) where derived speed is more than 20 knots")
```



```{r}
# Don't run step below for now
knitr::opts_chunk$set(eval = FALSE)
```


## Vessel in harbour (A point in polygon issue)

Example data: Icelandic survey tracks and some harbour polygons

```{r}
harbours.sf <- 
  read_sf("ftp://ftp.hafro.is/pub/data/shapes/harbours.gpkg") %>% 
         # only harbours in Iceland
  filter(iso2a == "IS",
         # filter out some smaller harbours, cause a nuisance downstream
         !hid %in% c("HRI", "ASS", "HAU", "GRE", "MJH", "MJO", "AED", "HJA")) %>% 
  select(hid)

tracks.sf <- 
  read_is_survey_tracks() %>% 
  mutate(speed = ifelse(speed > 12, 12, speed)) %>% 
  st_as_sf(coords = c("lon", "lat"),
           crs = 4326,
           remove = FALSE) %>% 
  st_join(harbours.sf) %>% 
  mutate(inharbour = ifelse(!is.na(hid), TRUE, FALSE))
```

```{r}
bb <- st_bbox(c(xmin = -22.85, ymin = 63.70, 
                xmax = -21.65, ymax = 64.20), 
              crs = 4326)

mapdeck(location = c(-22.0, 64.1), zoom = 9) %>% 
  add_polygon(data = harbours.sf, fill_colour = "#FF000095", tooltip = "hid", update_view = FALSE) %>% 
  add_scatterplot(data = tracks.sf %>% st_crop(bb) %>% arrange(inharbour), 
                  fill_colour  = "inharbour", radius = 100, update_view = FALSE)
```

## Trip identification

One could define a trip as all the consecutive points while not in harbour. Determining if points are inside or outside a harbour have been dealt with above. The {data.table} `rleid` function deals with generating a run-length type group id

```{r}
# rleid(cumsum(!mydata$Info == "3D"))
# try a conditional rleid(cumsum(!inharbour == FALSE))
tracks <- 
  tracks.sf %>% 
  st_drop_geometry() %>% 
  # here we do not want to count harbour stay as a separate trip
  group_by(vid) %>% 
  mutate(.gr0 = data.table::rleid(inharbour)) %>% 
  group_by(vid, inharbour) %>% 
  mutate(tripid = data.table::rleid(.gr0)) %>% 
  ungroup() %>% 
  select(-.gr0)
tracks %>% 
  filter(vid == 1579) %>% 
  ggplot() +
  theme_void() +
  geom_path(aes(lon, lat, colour = as_factor(tripid)), lwd = 1) +
  geom_path(data = geo::island, aes(lon, lat), colour = "grey", lwd = 1) +
  scale_colour_brewer(palette = "Set1") +
  coord_quickmap() +
  labs(colour = "Trip no") +
  theme(legend.position = "bottom")
```

We can take a peek at the trip info's:

```{r}
tracks %>% 
  filter(vid == 1579) %>% 
  group_by(tripid) %>% 
  mutate(distance = geo::arcdist(lat, lon, lead(lat), lead(lon)),
         distance = replace_na(distance, 0)) %>% 
  summarise(n = n(),
            distance = sum(distance), # nautical miles
            t1 = min(time),
            t2 = max(time),
            das = as.numeric(difftime(t2, t1, units = "days")))
```

We see here that trip 5 is very short, the problem lies with having a wacky point, that needs to be fixed upstream:
```{r}
tracks %>% 
  filter(vid == 1579) %>% 
  slice(2370:2380) %>% 
  mutate(dist = geo::arcdist(lat, lon, lead(lat), lead(lon))) %>% 
  select(vid:lat, hid:dist) %>% 
  knitr::kable(digits = 2)
```

One way to exclude the wacky points without actually removing them from the time series is:

```{r}
tracks %>% 
  filter(vid == 1579) %>% 
  slice(2370:2380) %>% 
  mutate(dist = geo::arcdist(lat, lon, lead(lat), lead(lon))) %>% 
  mutate(ID = 1:n()) %>% 
  # Need to find a robust algoritm that detects the first bad point
  mutate(wacky = ifelse(ID == 7, TRUE, FALSE)) %>% 
  group_by(vid, wacky) %>% 
  mutate(dist2 = geo::arcdist(lat, lon, lead(lat), lead(lon))) %>% 
  ungroup() %>% 
  select(vid:lat, hid:dist2) %>% 
  knitr::kable()
```



```{r, eval = FALSE, echo = FALSE}
d <- 
  tracks %>% 
  filter(vid == 1579) %>% 
  st_as_sf(coords = c("lon", "lat"),
           crs = 4326)
d2 <- 
  d %>% 
  st_drop_geometry() %>% 
  select(tripid) %>% 
  distinct()
pal <- c("#A6CEE3FF", "#1F78B4FF", "#B2DF8AFF", "#33A02CFF", "#FB9A99FF", 
        "#E31A1CFF", "#FDBF6FFF", "#FF7F00FF", "#CAB2D6FF", "#6A3D9AFF", 
        "#FFFF99FF", "#B15928FF")
d2$pal <- c(pal, pal)[1:nrow(d2)]
d <- 
  d %>% 
  left_join(d2)
mapdeck(style = mapdeck_style("dark")) %>% 
  add_scatterplot(data = d, 
                  fill_colour = "pal", 
                  tooltip = "tripid", 
                  legend = FALSE,
                  radius = 250,
                  radius_min_pixels = 2,
                  radius_max_pixels = 10)
```



## Calculation of trip length and duration, including cumulatives

```{r}
tracks <- 
  tracks %>% 
  group_by(vid, tripid) %>% 
  mutate(dist = geo::arcdist(lat, lon, lead(lat), lead(lon)),
         dist = replace_na(dist, 0),
         cdist = cumsum(dist),
         dura = as.numeric(difftime(lead(time), time, units = "hours")),
         dura = replace_na(dura, 0),
         cdura = cumsum(dura)) %>% 
  ungroup()
tracks %>% 
  filter(vid == 1579,
         !inharbour) %>% 
  ggplot() +
  theme_void() +
  geom_point(aes(lon, lat, colour = cdist)) +
  geom_path(aes(lon, lat, group = tripid), colour = "grey") +
  geom_polygon(data = geo::island, aes(lon, lat), fill = "grey") +
  scale_colour_viridis_c(option = "B", direction = -1) +
  coord_quickmap()
```


```{r, eval = FALSE}
# checkout: geosphere::distHaversine
tracks %>% 
  mutate(dist2 = geosphere::distHaversine(c(lon, lat)))
```

